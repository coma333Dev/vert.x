<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
    "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="bootstrap/bootstrap.css" type="text/css" rel="stylesheet" />

<link href="google-code-prettify/prettify.css" type="text/css"
	rel="stylesheet" />
<script type="text/javascript" src="google-code-prettify/prettify.js"></script>
<link href="css/vertx.css" type="text/css" rel="stylesheet" />
<link href="css/sunburst.css" type="text/css" rel="stylesheet" />
<title>Vert.x 웹 어플리케이션 튜토리얼</title>
<script>
	var _gaq = _gaq || [];
	_gaq.push([ '_setAccount', 'UA-35733016-2' ]);
	_gaq.push([ '_trackPageview' ]);
	(function() {
		var ga = document.createElement('script');
		ga.type = 'text/javascript';
		ga.async = true;
		ga.src = ('https:' == document.location.protocol ? 'https://ssl'
				: 'http://www')
				+ '.google-analytics.com/ga.js';
		var s = document.getElementsByTagName('script')[0];
		s.parentNode.insertBefore(ga, s);
	})();
</script>
</head>

<body onload="prettyPrint()">

	<div class="navbar navbar-fixed-top">
		<div class="navbar-inner">
			<div class="container">

				<a class="btn btn-navbar" data-toggle="collapse"
					data-target=".nav-collapse"> <span class="i-bar"></span> <span
					class="i-bar"></span> <span class="i-bar"></span>
				</a> <a class="brand" href="/">vert.x</a>

				<div class="nav-collapse">
					<ul class="nav">
						<li><a href="/">홈</a></li>
						<li><a href="downloads.html">다운로드</a></li>
						<li><a href="install.html">설치</a></li>
						<li class="active"><a href="tutorials.html">튜토리얼</a></li>
						<li><a href="examples.html">예제</a></li>
						<li><a href="docs.html">문서</a></li>
						<li><a href="https://github.com/vert-x/vert.x">코드</a></li>
						<li><a href="http://groups.google.com/group/vertx">구글 그룹</a></li>
						<li><a href="community.html">커뮤니티</a></li>
						<li><a href="http://vertxproject.wordpress.com/">블로그</a></li>
					</ul>
				</div>
			</div>
		</div>
	</div>

	<div class="container">

		<div class="row">
			<div class="span12">
				<div class="well">
					<h1 style="font-size: 35px;">자바스크립트 웹 어플리케이션 만들기</h1>
				</div>
			</div>
		</div>

		<div class="row">
			<div class="span12">
				<div class="well">
					<div>


						<p>자 vert.x 를 이용해서 실시간 웹 어플리케이션을 만들어 봅시다.</p>
						<p>우리는 "vToons" 라는 음반 쇼핑 어플리케이션을 만들 겁니다.</p>
						<p>이 어플리케이션의 구조는 굉장히 간단합니다. 서버의 vert.x 이벤트 버스를 통해 persistor
							모듈과 클라이언트측 JavaScript MVVM (MVC) 어플리케이션이 통신하는 구조로 구성되어 있습니다.
							persistor 모듈은 음반 상품을 저장하고 주문을 처리하는데 쓰입니다.</p>
						<p>또한 html, css 그리고 js파일과 같은 정적인 파일들을 출력하는 웹 서버 모듈이 있습니다.</p>
						<p>
							<strong>이 어플리케이션을 위해 따로 모듈을 만들 필요는 없습니다</strong>. 우리는 클라이언트 측
							자바스크립트 어플리케이션만 작성해주면 됩니다. 어플리케이션과 persistor는 로컬에서 돌아가는 듯 작동할
							것입니다.
						</p>
						<p>당신은 서버에 persistor와 웹 서버를 시작하게 하는 간단한 스크립트만 작성하면 됩니다. 이
							스크립트에는 어플리케이션에 필요한 설정을 포함시킬수 도 있습니다.</p>
						<p>이 튜토리얼은 자바스크립트로 이용하는 유저를 위한 것입니다. Ruby나 Groovy를 이용해 ver.x를
							작동시키고 싶다면 해당 언어의 튜토리얼을 참고하세요.</p>
						<p>
							완성된 코드를 돌려보기만 하고 싶다면 배포판 내에 있는 예제 중
							<code>webapp</code>
							디렉토리의 파일을 이용하세요. README 파일에 어떻게 예제 코드를 실행시킬 수 있는지 나와있습니다.
						</p>
						<p>
							이 코드는 <a
								href="https://github.com/vert-x/vert.x/tree/master/vertx-examples/src/main/javascript/webapp">github</a>
							에서도 볼 수 있습니다.
						</p>
						<h2 id="step-1-install-vertx">1 단계. Vert.x 설치하기</h2>
						<br />
						<p>
							아직 vert.x 설치를 안하셨나요? <a href="install.html">그럼 여기에서 설치합니다</a>.
						</p>
						<p>
							다음 부분부터는 vert.x 를
							<code>VERTX_HOME</code>
							에 설치한 것으로 간주하고 진행합니다.
						</p>
						<h2 id="step-2-get-the-web-server-running">2단계. 서버 돌리기</h2>
						<br />
						<p>정적인 파일들을 출력하기 위해 웹 서버가 필요합니다. Vert.x 에서 몇 줄의 코드로 웹 서버를 만들 수
							있습니다. 하지만 그럴 필요조차 없습니다. Vert.x 에는 아주 좋은 웹 서버 모듈이 있습니다. 우린 그걸 이용할
							겁니다.</p>
						<p>웹 서버를 구성하고 시작하는 스크립트를 작성해 봅시다.</p>
						<p>텍스트 에디터를 열어서 다음 코드를 복사해 넣어봅시다.</p>
						<pre class="prettyprint">load('vertx.js');

var webServerConf = {  
  port: 8080,
  host: 'localhost'
};

// Start the web server, with the config we defined above

vertx.deployModule('vertx.web-server-v1.0', webServerConf);
</pre>
						<p>
							<code>deployModule</code>
							을 호출해서
							<code>vertx.web-server</code>
							모듈의 인스턴스를 deploy 합니다. 모듈이 설치되어 있지 않다면 vert.x는 저장소를 통해 모듈을 자동으로
							설치할 겁니다. 모듈에 대한 자세한 정보는 모듈 매뉴얼을 참고하도록 합시다.
						</p>
						<p>
							<code>app.js</code>
							로 저장합니다.
						</p>
						<p>
							이제
							<code>web</code>
							이라는 디렉토리를 만들고 그 안에
							<code>index.html</code>
							파일을 넣습니다.
						</p>
						<pre class="prettyprint">mkdir web
echo "&lt;html&gt;&lt;body&gt;Hello World&lt;/body&gt;&lt;/html&gt;" &gt; web/index.html
</pre>
						<p>그리고 서버를 돌려봅시다.</p>
						<pre class="prettyprint">vertx run app.js
</pre>
						<p>
							브라우저에서
							<code>http://localhost:8080</code>
							를 열어 봅시다. 'Hello World' 라는 문구가 나오는 페이지가 열릴겁니다. <br />
						</p>
						<p>자 웹 서버가 만들어 졌습니다.</p>
						<h2 id="step-3-serve-the-client-side-app">3 단계. 클라이언트 측
							application 만들기</h2>
						<br />
						<p>잘 돌아가는 웹 서버를 만들었고 이제 클라이언트 측 어플리케이션을 만들어 보도록 하죠.</p>
						<p>
							이 예제에서는 <a href="http://knockoutjs.com/">knockout.js</a> 와 <a
								href="http://twitter.github.com/bootstrap/">Twitter
								bootstrap</a> 을 이용해 어플리케이션을 작성할 겁니다. 하지만 당신이 사용하기 편리한 다른 어떤 스크립트 툴을
							이용해도 상관없습니다. (예를들면 jQuery, backbone.js, ember.js 같은)
						</p>
						<p>서운해 하지 마세요. 이 튜토리얼에서는 knockout.js 나 Twitter bootstrap 가 어떻게 작동하고 이들을
							어떻게 다루는지는 설명하지 않을겁니다.</p>
						<p>다음처럼 vert.x 설치 경로에서 web 디렉토리를 복사합시다.</p>
						<pre class="prettyprint">cp -r $VERTX_HOME/examples/javascript/webapp/web/* web
</pre>
						<p>이제 브라우저에서 페이지를 새로고침 해봅시다. 클라이언트 측 어플리케이션이 나타날 겁니다.</p>
						<p>당연히 아직 아무 쓸만한 기능도 제공하지 않습니다. 아무것도 연결한게 없으니까요. 그래도 레이아웃을 볼
							수는 있습니다. 다음처럼 나타나겠죠.</p>
						<p>
							<img alt="Client Application" src="tutorial_1.png" />
						</p>
						<p>잠시 이것저것 클릭해 봅시다. 어플리케이션을 이해하는데 도움이 될 겁니다.</p>
						<p>가운데에는 상품과 장바구니를 조회할 수 있는 각각의 탭이 위치해 있습니다.</p>
						<p>
							왼쪽에는 로그인 할 수 있는 폼이 있네요.<br />
						</p>
						<h3 id="step-4-get-the-persistor-up-and-running">4단계.
							Persistor 를 올리고 실행시키기</h3>
						<br />
						<p>
							Vert.x 모듈 저장소에는
							<code>vertx.mongo-persistor</code>
							라는 모듈이 있습니다.
						</p>
						<p>이 모듈을 가지고 MongoDB 데이터베이스에서 데이터를 저장/수정/삭제/검색 할 수 있습니다. (모듈의
							자세한 정보는 모듈 매뉴얼을 참고하세요.)</p>
						<p>우리는 이 persistor 를 이용해 어플리케이션에 다음 기능을 구현해 볼 겁니다.</p>
						<ul>
							<li>음반의 카탈로그를 저장</li>
							<li>사용자의 이름과 비밀번호를 저장</li>
							<li>주문을 저장</li>
						</ul>
						<p>
							Persistor 를 시작하기 위해
							<code>app.js</code>
							를 다음과 같이 수정합니다.
						</p>
						<pre class="prettyprint">load('vertx.js');

var webServerConf = {  
  port: 8080,
  host: 'localhost'
};

// Start a MongoDB persistor module

vertx.deployModule('vertx.mongo-persistor-v1.0');

// Start the web server, with the config we defined above

vertx.deployModule('vertx.web-server-v1.0', webServerConf);
</pre>
						<p>이 전에 당연히 MongoDB 인스턴스가 로컬에 기본설정으로 제대로 설치되어 있어야 합니다.</p>
						<p>
							먼저 실행한 서버를 CTRL-C 로 정지시키고 다시
							<code>app.js</code>
							를 실행시킵니다.
						</p>
						<pre class="prettyprint">vertx run app.js
</pre>
						<p>Persistor 와 웹 서버가 같이 돌아가고 웹 서버는 이전 처럼 클라이언트 어플리케이션을 제공할 겁니다.</p>
						<h2 id="step-5-connecting-up-the-client-side-to-the-event-bus">5단계.
							클라이언트를 Event Bus 로 연결하기</h2>
						<br />
						<p>지금까지 웹 서버를 만들어 돌렸지만 서버측 persistor는 event bus를 기다릴 뿐 아무동작도
							하지 않았습니다.</p>
						<p>클라이언트 측과 연결해 event bus 를 통해 persistor와 상호작용 할 수 있게 만들어 봅시다.</p>
						<p>우리는 SockJS 브릿지를 이용할 겁니다.</p>
						<p>SockJS 기술을 통해 브라우저와 서버가 전이중 통신을 할겁니다. 마치 웹소켓 같은? 브라우저나
							네트워크가 웹 소켓을 지원하지 않더라도요.</p>
						<p>
							Vert.x API 를 이용해 SockJS 서버를 직접 만들수 있습니다. (API 매뉴얼에 자세한 내용이
							있습니다.), 하지만
							<code>vertx.web-server</code>
							모듈안에 브릿지 기능이 포함되어 있습니다. 우리는 이 기능을 활성화 시켜주기만 하면 됩니다.
						</p>
						<p>웹 서버 설정을 다음처럼 수정합니다.</p>
						<pre class="prettyprint">var webServerConf = {  
  port: 8080,
  host: 'localhost',
  bridge: true,

  inbound_permitted: [
    {
      address : 'vertx.mongopersistor',
      match : {
        action : 'find',
        collection : 'albums'
      }
    }
  ],
  outbound_permitted: [ {} ]
};
</pre>
						<p>
							<code>bridge</code>
							필드를
							<code>true</code>
							로 바꿈으로써 event bus 브릿지와 동시에 정적인 파일을 제공할 것입니다.
						</p>
						<p>
							또 새로운
							<code>inbound_permitted</code>
							와
							<code>outbound_permitted</code>
							필드가 있는데요, 이 JSON 배열들로 어떤 event bus 메세지를 허용할지 결정하게 됩니다. 기본적으로 브릿지는
							방화벽과 비슷한 역할을 하며 우리가 원하는 메세지만 통과할 수 있도록 합니다.
							<code>inbound_permitted</code>
							필드는 클라이언트 --&gt; 서버로 향하는 메세지를 결정하고
							<code>outbound_permitted</code>
							필드는 반대로 서버 --&gt; 클라이언트로 가는 메세지를 결정합니다.
						</p>
						<p>만약 클라이언트에 persistor로 향하는 모든 메세지를 허용한다면 누군가 데이터베이스의 모든 데이터를
							삭제한다거나 볼 권한이 없는 데이터를 조회 하는 무시무시한 결과를 초래 할 수도 있습니다.</p>
						<p>(방화벽이 작동하는 방식에 대한 자세한 설명은 vert.x 매뉴얼을 참조하세요.)</p>
						<p>처음에는 persistor에 앨범 데이터를 조회만 할수 있는 요청만 받으려고 합니다. 이 요청은 클라이언트
							측 어플리케이션에 구매할 수 있는 앨범을 표시하는데 필요합니다.</p>
						<p>
							위의 설정은 클라이언트로 부터
							<code>vertx.mongopersistor</code>
							(이건 MongoDB persistor 의 event bus 주소입니다.) 라는 주소의 메세지만 받게 합니다. 그리고
							<code>action</code>
							필드의 값
							<code>find</code>
							와
							<code>collection</code>
							필드의
							<code>albums</code>
							값만 허용할 겁니다.
						</p>
						<p>파일을 저장합니다.</p>
						<h2 id="step-6-inserting-the-static-data">6단계. 정적 데이터 삽입</h2>
						<br />
						<p>We're almost at the point where the client side app can see
							the catalogue data. But first we need to insert some static data.</p>
						<p>To do this we need a script which inserts catalogue and
							other data needed by the application in the database. It does
							this by sending JSON messages on the event bus to the persistor.</p>
						<p>
							Copy
							<code>static_data.js</code>
							into your directory as follows:
						</p>
						<pre class="prettyprint">cp $VERTX_HOME/examples/javascript/webapp/static_data.js .
</pre>
						<p>
							We want to insert the static data only after the persistor
							verticle has completed starting up so we edit
							<code>app.js</code>
							as follows:
						</p>
						<pre class="prettyprint">vertx.deployModule('vertx.mongo-persistor-v1.0', null, 1, function() {
  load('static_data.js');
});
</pre>
						<p>
							The function that we're specifying in the call to
							<code>deployModule</code>
							won't be invoked until the persistor is fully started. In that
							function we just load the static data script.
						</p>
						<p>
							Save the edited
							<code>app.js</code>
							and restart it.
						</p>
						<pre class="prettyprint">vertx run app.js
</pre>
						<p>Refresh your browser.</p>
						<p>You should now see the catalogue displayed in the client
							side app:</p>
						<p>
							<img alt="Client Application" src="tutorial_2.png" /><br />
						</p>
						<p>Now there is some stuff to buy, you should be able to add
							stuff to your cart, and view the contents of your cart by
							clicking on the cart tab.</p>
						<h2 id="step-7-requesting-data-from-the-server">Step 7.
							Requesting data from the server</h2>
						<br />
						<p>As previously mentioned, this isn't a tutorial on how to
							write a knockout.js client-side application, but let's take a
							quick look at the code in the client side app that requests the
							catalogue data and populates the shop.</p>
						<p>
							The client side application JavaScript is contained in the file
							<code>web/js/client_app.js</code>
							. If you open this in your text editor you will see the following
							line, towards the top of the script:
						</p>
						<pre class="prettyprint">var eb = new vertx.EventBus(window.location.protocol + '//' + window.location.hostname + ':' + window.location.port + '/eventbus');
</pre>
						<p>
							This is using the
							<code>vertxbus.js</code>
							library to create an
							<code>EventBus</code>
							object. This object is then used to send and receive messages
							from the event bus.
						</p>
						<p>If you look a little further down the script, you will find
							the part which loads the catalogue data from the server and
							renders it:</p>
						<pre class="prettyprint">eb.onopen = function() {

    // Get the static data

    eb.send('vertx.mongopersistor', {action: 'find', collection: 'albums', matcher: {} },
      function(reply) {
        if (reply.status === 'ok') {
          var albumArray = [];
          for (var i = 0; i &lt; reply.results.length; i++) {
            albumArray[i] = new Album(reply.results[i]);
          }
          that.albums = ko.observableArray(albumArray);
          ko.applyBindings(that);
        } else {
          console.error('Failed to retrieve albums: ' + reply.message);
        }
      });
  };
</pre>
						<p>
							The
							<code>onopen</code>
							is called when, unsurprisingly, the event bus connection is fully
							setup and open.<br />
						</p>
						<p>
							At that point we are calling the
							<code>send</code>
							function on the event bus to a send a JSON message to the address
							<code>vertx.mongopersistor</code>
							. This is the address of the MongoDB persistor module that we
							configured earlier.
						</p>
						<p>
							The JSON message that we're sending specifies that we want to
							find and return all albums in the database. (For a full
							description of the operations that the MongoDBPersistor module
							expects you can consult the README.md in the
							<code>mod-mongo-persistor</code>
							repository).
						</p>
						<p>
							The final argument that we pass to to
							<code>send</code>
							is a reply handler. This is a function that gets called when the
							persistor has processed the operation and sent the reply back
							here. The first argument to the reply handler is the reply
							itself.
						</p>
						<p>
							In this case, the reply contains a JSON message with a field
							<code>results</code>
							which contains a JSON array containing the albums.
						</p>
						<p>Once we get the albums we give them to knockout.js to
							render on the view.</p>
						<h2 id="step-8-handling-login">Step 8. Handling Login</h2>
						<br />
						<p>In order to actually send an order, you need to be logged
							in.</p>
						<p>
							To handle login we will start an instance of the
							<code>vertx.auth-mgr</code>
							which lives in the repository. This is a simple module which
							handles simple user/password authentication and authorisation.
							Users credentials are stored in the MongoDB database. Fore more
							sophisticated auth, you can easily write your own auth module and
							the bridge can talk to that instead.
						</p>
						<p>
							To login, the client sends a message on the event bus to the
							address
							<code>vertx.basicauthmanager.login</code>
							with fields
							<code>username</code>
							and
							<code>credentials</code>
							, and if successful it replies with a message containing a unique
							session id, in the
							<code>sessionID</code>
							field.
						</p>
						<p>This session id should then be sent in any subsequent
							message from the client to the server that requires
							authentication (e.g. persisting an order).</p>
						<p>
							When the bridge receives a message with a
							<code>sessionID</code>
							field in it, it will contact the auth manager to see if the
							session is authorised for that resource.
						</p>
						<p>
							Let's add a line to start the
							<code>auth-mgr</code>
							:
						</p>
						<p>
							Edit
							<code>app.js</code>
							and add the following, just after where the Mongo Persistor is
							deployed.
						</p>
						<pre class="prettyprint">// Deploy an auth manager to handle the authentication

vertx.deployModule('vertx.auth-mgr-v1.0');
</pre>
						<p>We'll also need to tell the bridge to let through any login
							messages:</p>
						<pre class="prettyprint">inbound_permitted: [
  // Allow calls to login and authorise
  {
    address: 'vertx.basicauthmanager.login'
  },
  ...
</pre>
						<p>Save, and restart the app.</p>
						<p>
							You can test login by attempting to log-in with username
							<code>tim</code>
							and password
							<code>password</code>
							. A message should appear on the left telling you you are logged
							in!
						</p>
						<p>
							<img alt="Client Application" src="tutorial_3.png" />
						</p>
						<p>Let's take a look at the client side code which does the
							login.</p>
						<p>
							Open
							<code>web/js/client_app.js</code>
							and scroll down to the
							<code>login</code>
							function. This gets trigged by knockout when the login button is
							pressed on the page.
						</p>
						<pre class="prettyprint">eb.send('vertx.bridge.login', {username: that.username(), password: that.password()}, function (reply) {
    if (reply.status === 'ok') {
      that.sessionID(reply.sessionID);
    } else {
      alert('invalid login');
    }
  });
</pre>
						<p>As you can see, it sends a login JSON message to the bridge
							with the username and password.</p>
						<p>
							When the reply comes back with status
							<code>ok</code>
							, it stores the session id which causes knockout to display the
							"Logged in as... " message.
						</p>
						<p>It's as easy as that.</p>
						<h2 id="step-9-persisting-orders">Step 9. Persisting Orders</h2>
						<br />
						<p>Persisting an order is equally simple. We just send a
							message to the MongoDB persistor component saying we want to
							store the order.</p>
						<p>We also need to tell the bridge to let through requests to
							persist an order. We also need to add the further constraint that
							only logged-in users can persist orders.</p>
						<p>Edit the web server configuration so it looks like:</p>
						<pre class="prettyprint">var webServerConf = {  
  port: 8080,
  host: 'localhost',
  bridge: true,

  // This defines which messages from the client we will let through
  // from the client
  inbound_permitted: [
    // Allow calls to login and authorise
    {
      address: 'vertx.basicauthmanager.login'
    },
    // Allow calls to get static album data from the persistor
    {
      address : 'vertx.mongopersistor',
      match : {
        action : 'find',
        collection : 'albums'
      }
    },
    {
      address : 'vertx.mongopersistor',
      requires_auth : true,  // User must be logged in to send let these through
      match : {
        action : 'save',
        collection : 'orders'
      }
    }
  ],
  outbound_permitted: [ {} ]
};
</pre>
						<p>
							Setting the
							<code>requires_auth</code>
							field to
							<code>true</code>
							means the bridge will only let through the message if the user is
							logged in.
						</p>
						<p>Ok, let's take a look at the client side code which sends
							the order.</p>
						<p>
							Open up
							<code>web/js/client_app.js</code>
							again, and look for the function
							<code>submitOrder</code>
							.
						</p>
						<pre class="prettyprint">that.submitOrder = function() {

  if (!orderReady()) {
    return;
  }

  var orderItems = ko.toJS(that.items);
  var orderMsg = {
    sessionID: that.sessionID(),
    action: "save",
    collection: "orders",
    document: {
      username: that.username(),
      items: orderItems
    }
  }

  eb.send('vertx.mongopersistor', orderMsg, function(reply) {
    if (reply.status === 'ok') {
      that.orderSubmitted(true);
      // Timeout the order confirmation box after 2 seconds
      // window.setTimeout(function() { that.orderSubmitted(false); }, 2000);
    } else {
      console.error('Failed to accept order');
    }
  });
};
</pre>
						<p>
							This function converts the order into a JSON object, then calls
							<code>send</code>
							on the event bus to send it to the database where it will get
							persisted.
						</p>
						<p>
							Notice that we add a
							<code>sessionID</code>
							field to the message with the session id that was returned when
							we logged in. The bridge requires this field to be set with a
							valid session id or the message will not make it through the
							bridge firewall, since we set the
							<code>requires_auth</code>
							field to true in the server side config.
						</p>
						<p>When the reply comes back we tell knockout to display a
							message.</p>
						<p>Everything should be in order, so restart the app again:</p>
						<pre class="prettyprint">vertx run app.js
</pre>
						<p>Refresh the browser.</p>
						<p>Now log-in and add a few items into your cart. Click to the
							cart tab and click "Submit Order". The message "Your order has
							been accepted, an email will be on your way to you shortly"
							should be displayed!</p>
						<p>Take a look in the console window of the application. You
							should see the order has been logged.</p>
						<p>
							<img alt="Client Application" src="tutorial_4.png" />
						</p>
						<p>
							<strong> Congratulations! You have just placed an order.
							</strong>
						</p>
						<h2 id="step-11-securing-the-connection">Step 11. Securing
							the Connection</h2>
						<br />
						<p>So far in this tutorial, all client-server traffic has been
							over an unsecured socket. That's not a very good idea in a real
							application since we're sending login credentials and orders.</p>
						<p>Configuring Vert.x to use secure sockets is very easy. (For
							detailed information on configuring HTTPS, please see the
							manual).</p>
						<p>
							Edit
							<code>app.js</code>
							again, and add the field
							<code>ssl</code>
							in the web server config, with the value
							<code>true</code>
							.
						</p>
						<pre class="prettyprint">var webServerConf = {  
  port: 8080,
  host: 'localhost',
  ssl: true,
  bridge: true,
  ...
</pre>
						<p>
							You'll also need to provide a key store. The keystore is just a
							Java keystore which contains the certificate for the server. It
							can be manipulated using the Java
							<code>keytool</code>
							command. <br />
						</p>
						<p>Copy the keystore from the distribution</p>
						<pre class="prettyprint">cp $VERTX_HOME/examples/javascript/webapp/server-keystore.jks .
</pre>
						<p>Now restart the app again.</p>
						<pre class="prettyprint">vertx run app.js
</pre>
						<p>
							And go to your browser. This time point your browser at
							<code>https://localhost:8080</code>
							. <em>Note it is <strong>https</strong> not http
							</em>.
						</p>
						<p>
							<em>You'll initially get a warning from your browser saying
								the server certificate is unknown. This is to be expected since
								we haven't told the browser to trust it. You can ignore that for
								now. On a real server your server cert would probably be from a
								trusted certificate authority.</em>
						</p>
						<p>Now login, and place an order as before.</p>
						<p>
							Easy peasy. <strong>It just works</strong>
						</p>
						<h2 id="step-12-scaling-the-application">Step 12. Scaling the
							application</h2>
						<br />
						<h3 id="scaling-the-web-server">Scaling the web server</h3>
						<br />
						<p>
							Scaling up the web server part is trivial. Simply start up more
							instances of the webserver. You can do this by changing the line
							that starts the
							<code>vertx.web-server</code>
							module to something like:
						</p>
						<pre class="prettyprint">// Start 32 instances of the web server!

vertx.deployModule('vertx.web-server-v1.0', webServerConf, 32);
</pre>
						<p>
							(<em>Vert.x is clever here, it notices that you are trying
								to start multiple servers on the same host and port, and
								internally it maintains a single listening server, but round
								robins connections between the various instances</em>.)
						</p>
						<h3 id="more-complex-web-applications">More complex web
							applications</h3>
						<br />
						<p>In this simple web application, there was no need to write
							any custom server side modules, but in more complex applications
							you might want to write your own server side services which can
							be used by clients (or by other server side code).</p>
						<p>Doing this with Vert.x is very straightforward. Here's an
							example of a trivial server side service which listens on the
							event bus for messages and sends back the current time to the
							caller:</p>
						<pre class="prettyprint">load('vertx.js');

vertx.eventBus.registerHandler("acme.timeService", function(message, replier) {
    replier({current_time: new Date().getTime()});        
});
</pre>
						<p>
							Save this in
							<code>time_service.js</code>
							, and add a line in your
							<code>app.js</code>
							to load it on startup.
						</p>
						<p>Then you can just call it from client side JavaScript, or
							other server side components:</p>
						<pre class="prettyprint">eventBus.send("acme.timeService", null, function(reply) {
    console.log("Time is " + reply.current_time);
});
</pre>
						<h3 id="packaging-up-your-code-as-a-module">Packaging up your
							code as a Module</h3>
						<br />
						<p>You can package up your entire application, or just
							individual Verticles as modules, so they can be easily reused by
							other applications, or started on the command line more easily.</p>
						<p>
							For an explanation of how to do this, please see the modules
							manual. <br />
						</p>
					</div>
				</div>
			</div>
		</div>

	</div>

</body>
</html>
